#Java言語で学ぶデザインパターン入門【マルチスレッド編】

Java言語を通してマルチスレッドと並行処理のパターンを学ぶことが目的。マルチスレッドには下記のようなシングルスレッドではない注意しなければならない懸念点がる。

* データの破壊
* デッドロック
* リソースの大量消費

これら問題を解決するのは困難であり、そのため行き当たりばったりではなく、よく使われるパターンを覚え、その場に応じて適用することがよい。


##UMLについて
マルチスレッドの前に、UML(Unified Modeling Launguage)について簡単に説明する。これは、システムを視覚化したり、仕様や設計を文書化したりするための表現方法である。  

	[UMLの基本用語]  
	* アトリビュート（属性）：Javaのフィールド,C++のメンバ変数
	* オペレーション（操作）：Javaのメソッド、C++のメンバ関数

###クラス図

- 白抜きの三角（△）矢印の実践  
クラスの階層関係を表現しており、サブクラスからスーパークラスへ向かって表記する。**サブクラスは必ずスーパークラスを知っているため指すことができると覚えると覚えやすい**。  
- 白抜きの三角（△）の破線  
インタフェースと実装クラスの関係。これも階層関係と同じで、**実装クラスはインターフェースを知っているため指すことができると覚えれば良い**。











##1 Java言語のスレッド

スレッドとはプログラムを実行している主体のことであり、どんなプログラムもメインスレッドをもつ。
マルチスレッドとは、メインスレッドだけでなく他に複数のスレッドがあることを意味する。マルチスレッドが関わる一般的なケースとしては下記のようなケースがある。

1. GUIアプリケーション
2. 時間がかかるI/O処理
3. 複数のクライアント


###Javaでのマルチスレッドの実行方法

###1. Threadクラスの拡張
Threadクラスを継承したクラスのrunメソッドを実装。そのサブクラスのインスタンスを作成して、startメソッドを呼び出す。**runメソッドを呼び出した場合は別スレッドを起動せずに、その呼び出元のスレッドでrunの中身を実行してしまうため、マルチスレッドにならないので注意が必要。**
  

	public class MyThread extends Thread{
		public void run(){
			// 別スレッドで実行したい処理の記述
		}
	}
	
	MyThread thread = new MyThread();
	thread.start();// run()を呼び出すと同一スレッドで実行

#### 用語説明 
1. 逐次 - sequential:   
 順番に処理する
2. 並列 - parallel:   
複数人で分担して処理する
3. 並行 - concurrent:   
複数作業に分割し、処理する。つまり、一人でも複数でも実施される可能性がある。

 
 
###2. Runnableインターフェース

	public class Printer implements Runnable{
		public Printer(){
		}
		public void run(){
			//別スレッドで実施される処理
		}
	}
	
	new Thread(new Printer()).start();


###3 スレッドの一時停止
sleepでスレッドは一時停止可能。

	try{
		Thread.sleep(1000);
	} catch (InterruptedException e){
	}
	
### スレッドの排他制御
同じ変数に複数のスレッドがアクセスする場合、条件分や前提条件がうまく動作しない場合がでてくる。例えば、100円のジュースを買うと考えた際に、

1. 財布に100円あるかチェック
2. 現在の財布から100円を取り出す

という動作をすべてのスレッドが同じ財布で実施したと考えると、スレッドAとBがそれぞれ同時に財布を確認し、先にスレッドAが購入してしまうと、本来だと (財布-(スレッドAの購入分))でチェックをしなければならないところ、スレッドBはすでにチェックを終えているため、そのまま購入し、マイナスになってしまうというような現象が発生する。ここでは、１と２の処理の間に他スレッドが割り込めてしまうことが問題である。この割り込みをブロックする制御のことを排他制御mutual exclusionという。Javaでは、syncrhronizedというキーワードで処理を固まりとして実施させることができ、それで排他制御を行うことができる。


##2 Single Threaded Executionパターン
Single Threaded Exceutionパターンとは、複数スレッドから同時に実行されるとデータが破壊されてしまう部分(クリティカルセクション)は、かならず一つのスレッドからしか実行できないようにするパターンのことを言う。例えば、上記のスレッドの排他制御での財布からお金を取り出す例で考えると、お金のチェック(1)とお金の取り出す部分(2)の連続した処理がクリティカルセクションであると考えられるため、その部分を例えば以下のようにする。

	final public class 財布{
 		private int 財布のお金;
 		
 		財布(初期のお金){
 			財布のお金 = 初期のお金
 		}
		public sinchronized boolean 財布からお金取得(){
			if(財布の中身チェック){
				財布から取り出す;
				return true;
			}
			return false;
		}
	}

この財布クラスをインスタンス化(財布 test)し、スレッド間で共有すれば、「データが破壊されること」=「財布の中身が0未満になること」はなくなる。なお、クラスをfinal、財布のお金をprivateにしているのは、以下のような理由からである。

- クラスをfinalにしている理由  
継承を許してしまうと予期せぬ使い方をされる場合があるため。例えば、財布のお金を増やすインスタンスメソッドの追加など。もちろん注意して作成すれば(sinchronizedすればいいだけ)スレッドセーフにできる。

- 財布のお金をprivateいている理由  
せっかく財布からお金取得メソッドをsynchronizedにすることで排他制御をしているにもかかわらず、財布のお金をprivateではなくpublicにしてしまうと財布クラスのインスタンスで直接変更(財布のインスタンス.財布のお金 = 0)されてしまい、それによってデータが破壊されてしまう恐れがある。

##3 Immutable
読みのみということ。読みのみにすることでそもそも値が変更されないため、データが破壊されることがなくなり、排他制御を考える必要がなくなる。



##4 Guarded Suspensionパターン
条件を満たすまで待たせるような処理のこと


##5 Producer-Consumerパターン
Producer作ったデータをConsumerが取得するようなパターン。受け渡しのため、間にChanel役を置きそのChanel役によって排他制御を実施する。

### InterruptedExceptionについて
時間の掛かる処理、wait、sleep、joinを実施しているスレッドのインスタンスメソッドのinterruptを呼び出した直後(waitのみロックを取得する必要がある)に投げられるエラー。interruptを呼び出した際に、wait/sleep/joinで待ち状態に成っていない場合は、直後にエラーは投げられず、それらメソッドが呼び出された直後にエラーが投げれる。これはinterruptがステータスを変化しているだけであるためである。






